import sys
import os
import sst
from ariel_utils import parseAriel
import SimulationArgs
import argparse
import pathlib


# Globals
NCORES            = 1
LATENCY           = '100ps'
LAT2              = '50ps'
CORE_FREQ         = '2.0GHz'
UNCORE_FREQ       = '1.0GHz'
MEM_FREQ          = '500MHz'
COHERENCE         = 'MESI'
REPLACEMENT       = 'lru'
CACHE_LINE_BYTES  = '64'

# Levels that we can place a Parrot above
ALLOWED_PARROTS   = ['l1', 'l2', 'mem']

# Utility method
def mklink(e1, e2):
      link = sst.Link('link___' + e1[0].getFullName() + '__' + e1[1] + '___' +
                                 e2[0].getFullName() + '__' + e2[1])
      link.connect(e1, e2)
      return link

def usage():
      print(f'Usage: sst [sst arguments] -- <config file>:<benchmark name> [parrot_levels]')
      print('The config file is generated by `generate.py`. The `benchmark name` should be a key in the dict generated by generate.py')
      print('parrot_levels is a comma-separated list of levels above which a parrot will be placed, e.g. l1,l2,mem')
      sys.exit(1)

def parseConfig(config_filename, bench):

      if not os.path.isfile(config_filename):
            print(f'Error: config file `{config_filename}` not found')
            usage()

      with open(config_filename) as configfile:
            lines = configfile.readlines()
            allconfig = eval(''.join(lines))

      if bench not in allconfig:
            print(f'Error: `{bench}` not found in dict generated from `{config_filename}`')
            usage()

      ariel_command = parseAriel(allconfig[bench]['cmd'])

      # If the workload has markers, we set mode to 0 to scope the simulation
      ariel_markers = False
      if 'ariel_markers' in allconfig[bench]:
            ariel_markers = allconfig[bench]['ariel_markers']
      if (ariel_markers):
            arielmode=0
      else:
            arielmode=1

      return ariel_command, allconfig[bench]['directory'], arielmode

def enableStats(stats_file):
      # Satatistics
      #for i in range(NCORES):
      #      l1cache[i].enableStatistics(['GetS_recv','CacheHits', 'CacheMisses','TotalEventsReceived','MSHR_occupancy' ])
      #core.enableStatistics(['split_read_reqs'])
      #l2cache.enableStatistics(['GetS_recv','CacheHits', 'CacheMisses','TotalEventsReceived','MSHR_occupancy' ])

      # Define SST core options
      sst.setProgramOption('timebase', '1ps') # Change to 250ps?
      sst.setStatisticLoadLevel(10)
      #sst.enableAllStatisticsForAllComponents()

      # For MM, we found that no transaction took long than 1000ns. HBM access latency should be around 107ns (https://arxiv.org/pdf/2005.04324.pdf)
      histParams = {
            'type'     : 'sst.HistogramStatistic',
            'minvalue' : '0',
            'binwidth' : '10',
            'numbins'  : '100',
            'IncludeOutOfBounds' : '1'
      }
      sst.enableStatisticForComponentType('memHierarchy.Parrot', 'Latency', histParams)
      sst.enableStatisticForComponentType('ariel.ariel', 'instruction_count')
      sst.enableStatisticForComponentType('ariel.ariel', 'no_ops')
      sst.enableStatisticForComponentType('ariel.ariel', 'cycles')
      sst.enableStatisticForComponentType('ariel.ariel', 'latency')


      sst.enableStatisticForComponentType('memHierarchy.Parrot', 'num_requests')
      sst.enableStatisticForComponentType('memHierarchy.Parrot', 'num_responses')
      sst.enableStatisticForComponentType('memHierarchy.Parrot', 'num_normal_requests')
      sst.enableStatisticForComponentType('memHierarchy.Parrot', 'num_mf_requests')

      sst.setStatisticOutput('sst.statOutputCSV', {'filepath' : stats_file, 'separator' : ', ' } )

params = {
      'core' : {
            'verbose'        : 0,
            'corecount'      : NCORES,
            'cachelinesize'  : CACHE_LINE_BYTES,
            'envparamcount'  : 2,
            'envparamname0'  : 'OMP_NUM_THREADS',
            'envparamval0'   : str(NCORES),
            'envparamname1'  : 'LD_LIBRARY_PATH',
            'envparamval1'    : '/nethome/plavin3/sst/sst-tools/tools/ariel/api:/nethome/plavin3/sst/DRAMsim3-1.0.0:/nethome/plavin3/sst/pin-3.23/intel64/lib:/usr/lib64/openmpi/lib:/nethome/plavin3/sst/sst-tools/tools/ariel/api:/nethome/plavin3/sst/DRAMsim3-1.0.0:/nethome/plavin3/sst/pin-3.23/intel64/lib:/usr/lib64/openmpi/lib:/opt/slurm/current/lib',
            'clock'          : CORE_FREQ,
            'arielmode'      : 1,
            'maxissuepercycle': 1,
      },

      'l1cache' : {
            'cache_frequency'       : CORE_FREQ,
            'cache_size'            : '4KiB',
            'associativity'         : '4',
            'access_latency_cycles' : '2',
            'L1'                    : '1',
            'cache_line_size'       : CACHE_LINE_BYTES,
            'coherence_protocol'    : COHERENCE,
            'replacement_policy'    : REPLACEMENT,
#            'l1prefetcher'            : 'cassini.StridePrefetcher',
            'debug'                 : '0',
            'banks'                 : '8',
      },

      'l2cache' : {
            'access_latency_cycles' : '20',
            'cache_frequency'       : UNCORE_FREQ,
            'replacement_policy'    : REPLACEMENT,
            'coherence_protocol'    : COHERENCE,
            'associativity'         : '4',
            'cache_line_size'       : CACHE_LINE_BYTES,
#            'prefetcher'            : 'cassini.StridePrefetcher',
            'debug'                 : '0',
            'L1'                    : '0',
            'cache_size'            : '1MiB',
            'mshr_latency_cycles'   : '5',
            'banks'                 : '8',
      },

      'l1l2bus' : {
            'bus_frequency' : UNCORE_FREQ,
      },

      'memctrl' : {
            'clock'            : MEM_FREQ,
            'backing'          : 'none',
            'addr_range_end'   : 1024**3-1,
      },

      'backend' : {
            'config_ini'  : f'{os.environ["DRAMSIM3_HOME"]}/configs/HBM2_8Gb_x128.ini',
            'mem_size'    : '8GiB',
      },

      'parrot' : {
            'clock' : CORE_FREQ,
      },
}


if __name__ == '__main__':

      if os.getenv('DRAMSIM3_HOME') is None:
            print('Error: DRAMSIM3_HOME not found in environment')
            sys.exit(1)

      parser = argparse.ArgumentParser()
      parser.add_argument('config_file', help='file with configs')
      parser.add_argument('benchmark', help='benchmark rom config file to run')
      parser.add_argument('-p', '--parrot_levels', help='comma separated list of memory levels to add Parrots to', type=str, default=None)
      parser.add_argument('-P', '--parrot-freq', help='frequency of parrots', type=str, default='2.0GHz')
      parser.add_argument('-z', '--l1-cache', help='size of l1 cache', type=str, default='4KiB')
      parser.add_argument('-t', '--trace', help='enable tracing and specify directory to store trace', type=str, default=None)
      parser.add_argument('-r', '--rrfile', help='file to read RRs from', type=str, default=None)
      parser.add_argument('-M', '--multifidelity', help='whether to run a multifidelity simulation', action="store_true")
      parser.add_argument('-S', '--stats-file', help='where to put the output stats', default=os.path.join(os.getcwd(), 'two-level-stats.py'))
      args = parser.parse_args(sys.argv[1:])

      if args.l1_cache is not None:
            params['l1cache']['cache_size'] = args.l1_cache

      if args.parrot_freq is not None:
            params['parrot']['clock'] = args.parrot_freq

      parrot_levels = []
      if args.parrot_levels is not None:
            parrot_levels = args.parrot_levels.split(',')
            print(f'parrot levels: {parrot_levels}')

      for level in parrot_levels:
            if level not in ALLOWED_PARROTS:
                  print(f'Parrot level `{level}` not recognized!')
                  sys.exit(1)

      benchName = args.benchmark
      ariel_command, directory, arielmode = parseConfig(args.config_file, args.benchmark)
      #print(ariel_command)
      #print(directory)
      #print(arielmode)
      #panic

      print(f'Ariel command: {ariel_command}')
      print(f'Ariel directory: {directory}')

      # Save our current directory before chaning to the one that
      # the benchmark needs
      stats_file = pathlib.Path(args.stats_file)

      os.chdir(directory)

      # Print run information
      print(f'sdl: {sys.argv}')

      # Set param based on value from workload file
      params['core']['arielmode'] = arielmode

      # Make simulation objects
      core    = sst.Component('Ariel', 'ariel.ariel')
      l1cache = [sst.Component(f'L1Cache_{i}', 'memHierarchy.Cache') for i in range(NCORES)]
      l1l2bus = sst.Component('L1L2Bus', 'memHierarchy.Bus')
      l2cache = sst.Component('L2Cache', 'memHierarchy.Cache')
      memctrl = sst.Component('MemoryController', 'memHierarchy.MemController')
      backend = memctrl.setSubComponent('backend', 'memHierarchy.dramsim3')
      parrots = {}

      # Make parrots
      for level in parrot_levels:
            parrots[level] = sst.Component(f'Parrot_{level}', 'memHierarchy.Parrot')

      # Set up parameters
      core.addParams(params['core'])
      core.addParams(ariel_command)
      for i in range(NCORES):
            l1cache[i].addParams(params['l1cache'])
      l2cache.addParams(params['l2cache'])
      l1l2bus.addParams(params['l1l2bus'])
      memctrl.addParams(params['memctrl'])
      backend.addParams(params['backend'])

      for level in parrot_levels:
            parrots[level].addParams(params['parrot'])

            if args.trace is not None:
                  parrots[level].addParams({'enable_tracing' : True,
                                            'trace_prefix' : f'{args.trace}/Parrot_{level}_{benchName}'})
            if args.rrfile is not None:
                   parrots[level].addParams({'rr_temp' : f'{args.rrfile} {benchName}'})

            if args.multifidelity:
                  parrots[level].addParams({'enable_multifidelity' : True})

      # Only enable phase detection when we have Parrots,
      # otherwise the phase message will break the memory controller
      if (len(parrots) > 0):
            #core.addParams({'manual_pd':True})
            core.addParams({'phase_detection':True})
            #pass

      # By default, the Parrots will not foward the phase messages
      # but if we have more than one, we need the higher levels to
      # forward them.
      if len(parrot_levels) > 1:
            if 'l1' in parrot_levels:
                  parrots['l1'].addParams({'forward':True})
            if 'l2' in parrot_levels and 'mem' in parrot_levels:
                  parrots['l2'].addParams({'forward':True})


      # Ariel cores to L1 links
      if 'l1' in parrot_levels:
            for i in range(NCORES):
                  mklink( (core,          f'cache_link_{i}', LAT2),
                          (parrots['l1'], f'high_network_{i}', LAT2) )
                  mklink( (parrots['l1'], f'low_network_{i}',  LAT2),
                          (l1cache[i],     'high_network_0', LAT2) )
      else:
            for i in range(NCORES):
                  mklink( (core,       f'cache_link_{i}',   LATENCY),
                          (l1cache[i],  'high_network_0',   LATENCY) )

      # L1 to L1L2Bus links - Never parrot these
      for i in range(NCORES):
            mklink( (l1cache[i],  'low_network_0',    LATENCY),
                    (l1l2bus,    f'high_network_{i}', LATENCY))

      # L1L2Bus to L2 link
      if 'l2' in parrot_levels:
            mklink( (l1l2bus,       'low_network_0',  LAT2),
                    (parrots['l2'], 'high_network_0', LAT2) )
            mklink( (parrots['l2'], 'low_network_0',  LAT2),
                    (l2cache,       'high_network_0', LAT2) )
      else:
            mklink( (l1l2bus, 'low_network_0',  LATENCY),
                    (l2cache, 'high_network_0', LATENCY) )


      # L2 to Memory Controller link
      if 'mem' in parrot_levels:
            mklink( (l2cache,        'low_network_0',  LAT2),
                    (parrots['mem'], 'high_network_0', LAT2) )
            mklink( (parrots['mem'], 'low_network_0',  LAT2),
                    (memctrl,        'direct_link',    LAT2) )
      else:
            mklink( (l2cache, 'low_network_0', LATENCY),
                    (memctrl, 'direct_link',   LATENCY) )

      # Enable statistics
      enableStats(stats_file)
